= Exercises on coroutines and structured concurrency

== Introduction

Set of exercises about coroutines and structured concurrency.

== Exercises

=== Exercise 0

Consider the following definitions.

.Exercise 0
[source, kotlin]
----
private val logger = LoggerFactory.getLogger("labs")

fun logJobState(job: Job) {
    logger.info("isActive={}, isCancelled={}, isCompleted={}", job.isActive, job.isCancelled, job.isCompleted)
}

object Ex0 {
    @JvmStatic
    fun main(args: Array<String>) {
        // alternative: runBlocking(Dispatchers.Default) {
        runBlocking {
            logger.info("top coroutine started")
            launch {
                logger.info("child coroutine started")
            }
            logger.info("Before thread sleep")
            Thread.sleep(1000)
            // alternative: delay(1000)
            logger.info("After sleep/delay on top-coroutine")
        }
    }
}
----

* Why does `child coroutine started` only appear after `After sleep/delay on top-coroutine`?
** Porque o *launch* lan√ßa uma *coroutine* sem bloquear a thread corrente e retorna a refer√™ncia para a *coroutine* como um *Job*. Este *Job* √© depois executado pelo *dispatcher* padr√£o, que √© o *Default*. O *runBlocking* bloqueia a thread corrente at√© que todas as *coroutines* filhas terminem. Assim, o *runBlocking* n√£o termina at√© que o *Thread.sleep(1000)* termine. O *launch* n√£o bloqueia a thread corrente, ent√£o a execu√ß√£o continua e o *Thread.sleep(1000)* √© executado antes do *child coroutine started*.

* Will the behavior be different if `sleep` is replaced with `delay`? If so, explain why?
** Sim, o comportamento √© diferente. O *delay* n√£o bloqueia a thread corrente, enquanto o *sleep* bloqueia a thread corrente. Assim, quando o *delay* √© chamado, a execu√ß√£o da *coroutine* √© suspensa e a thread corrente pode ser usada para executar outras tarefas, como a execu√ß√£o da *child coroutine*. Portanto, o *child coroutine started* aparece antes de `After sleep/delay on top-coroutine`.

* Will the behavior be different if we keep `sleep` and use 
`runBlocking(Dispatchers.Default)` to start the top coroutine? If so, explain why?
** O comportamento j√° vai ser diferente. O *runBlocking(Dispatchers.Default)* usa diversos workers(threads) para executar o trabalho. Ent√£o o *child coroutine started* aparece antes de `After sleep/delay on top-coroutine`, porque o *runBlocking* n√£o bloqueia a thread corrente, mas sim o dispatcher padr√£o. Assim, a execu√ß√£o da *child coroutine* √© executada noutra thread enquanto o *Thread.sleep(1000)* est√° em execu√ß√£o.

=== Exercise 1

Consider the following definitions.

.Exercise 1
[source, kotlin]
----
object Ex1 {
    @JvmStatic
    fun main(args: Array<String>) {
        runBlocking {
            val continuationInterceptor: ContinuationInterceptor = coroutineContext[ContinuationInterceptor]
                ?: throw IllegalStateException("coroutine context does not have expected element")

            logger.info("step 0")
            withContext(Dispatchers.Default) {
                logger.info("step 1")
                withContext(continuationInterceptor) {
                    logger.info("step 2")
                }
                logger.info("step 3")
            }
            logger.info("step 4")
        }
    }
}
----

* Without running the code, write down on which thread (or thread group) will each of the `logger.info` statements be executed.
** step 0: main
** step 1: DefaultDispatcher-worker-1
** step 2: ContinuationInterceptor (main)
** step 3: DefaultDispatcher-worker-1
** step 4: main

* Confirm your analysis by running the code.
** Enganei-me e corri logo o c√≥digo üò≥

* What does the following statement do?
----
val continuationInterceptor: ContinuationInterceptor = coroutineContext[ContinuationInterceptor]
                ?: throw IllegalStateException("coroutine context does not have expected element")
----
** A linha acima tenta obter o elemento `ContinuationInterceptor` do contexto da *coroutine*. Se n√£o conseguir, lan√ßa uma exce√ß√£o `IllegalStateException`.

* Why can a `ContinuationInterceptor` be used as a context?
** Um `ContinuationInterceptor` pode ser usado como um contexto porque ele √© um elemento do contexto da *coroutine* que pode ser usado para interceptar a continua√ß√£o de uma *coroutine*. Permite controlar como e onde a continua√ß√£o de uma *coroutine* √© executada.

=== Exercise 2

Consider the following definitions.

.Exercise 2
[source, kotlin]
----
object Ex2 {
    @JvmStatic
    fun main(args: Array<String>) {
        runBlocking {
            val job = launch {
                try {
                    logger.info("Inner coroutine started")
                    delay(2000)
                } catch (ex: Throwable) {
                    logger.info("Caught exception {} - {}", ex.javaClass.simpleName, ex.message)
                }
            }
            delay(1000)
            logJobState(job)
            logger.info("Cancelling inner coroutine")
            job.cancel()
            logJobState(job)
            delay(1)
            logJobState(job)
        }
        logger.info("after runBlocking")
    }
}
----

* There is an exception being thrown inside the inner coroutine. Where is that exceptions thrown? Why is that exception thrown?
** A exce√ß√£o √© lan√ßada na linha `logger.info("Caught exception {} - {}", ex.javaClass.simpleName, ex.message)`. A exce√ß√£o √© lan√ßada porque a *coroutine* foi cancelada e o `delay` lan√ßa uma `CancellationException`.

* What is the type of the exception being thrown? Does that type derive from `kotlinx.coroutines.CancellationException`?
** O tipo da exce√ß√£o lan√ßada √© `job.CancellationException`. N√£o, o tipo n√£o deriva de `kotlinx.coroutines.CancellationException`.

* Why does the first log message after `job.cancel` have `isCompleted=false`, while the log message after `delay(1)` has `isCompleted=true`?
** A primeira mensagem de log ap√≥s `job.cancel` tem `isCompleted=false` porque a *coroutine* ainda n√£o terminou de executar. O `delay(1)` √© uma chamada de suspens√£o que permite que a *coroutine* cancele a execu√ß√£o e complete o trabalho. Assim, quando o `delay(1)` termina, a *coroutine* j√° foi cancelada e est√° completa.
=== Exercise 3

Consider the following definitions.

.Exercise 3
[source, kotlin]
----
object Ex3 {
    @JvmStatic
    fun main(args: Array<String>) {
        val scheduledExecutor = Executors.newSingleThreadScheduledExecutor()
        try {
            runBlocking {
                logger.info("top coroutine starting")
                val job = launch {
                    try {
                        suspendCancellableCoroutine { continuation ->
                            scheduledExecutor.schedule(
                                {
                                    logger.info("Calling continuation")
                                    continuation.resume(Unit)
                                },
                                1000,
                                TimeUnit.MILLISECONDS
                            )
                        }
                        logger.info("After suspendCancellableCoroutine")
                    } catch (ex: Throwable) {
                        logger.info("Caught exception {} - {}", ex.javaClass.simpleName, ex.message)
                    }
                }
                delay(500)
                job.cancel()
            }
        } finally {
            scheduledExecutor.shutdown()
        }
    }
}
----

* Is any exception thrown in the child coroutine? If so, why? Where is that exception thrown?
** Sim, uma exce√ß√£o √© lan√ßada na *coroutine* filha. A exce√ß√£o √© lan√ßada porque a *coroutine* foi cancelada antes que o `suspendCancellableCoroutine` pudesse ser conclu√≠do. A exce√ß√£o √© lan√ßada na linha `continuation.resume(Unit)`.

* Is the `continuation.resume` called before or after the `suspendCancellableCoroutine` call completes? Do you see any problem?
** O `continuation.resume` √© chamado depois  do `suspendCancellableCoroutine` ser conclu√≠do. O problema √© que a *coroutine* foi cancelada antes que o `suspendCancellableCoroutine` pudesse ser conclu√≠do, ent√£o a continua√ß√£o n√£o pode ser chamada.

* What is the behavior if the delay duration is changed to 1500 milliseconds?
** Se a dura√ß√£o do atraso for alterada para 1500 milissegundos, a *coroutine* n√£o ser√° cancelada antes que o `suspendCancellableCoroutine` seja conclu√≠do. Assim, a continua√ß√£o ser√° chamada e a mensagem `After suspendCancellableCoroutine` ser√° exibida.

* What is the behavior if the delay duration is kept at 500 milliseconds and the `suspendCancellableCoroutine` is replaced with a `suspendCoroutine`?
** Se a dura√ß√£o do atraso for mantida em 500 milissegundos e o `suspendCancellableCoroutine` for substitu√≠do por um `suspendCoroutine`, a *coroutine* ser√° cancelada na mesma e a mensagem `After suspendCancellableCoroutine` ser√° exibida.

=== Exercise 4

Consider the following definitions.

.Exercise 4
[source, kotlin]
----
object Ex4 {
    @JvmStatic
    fun main(args: Array<String>) {
        runBlocking {
            logger.info("top starting")
            val job1 = launch {
                try {
                    delay(1000)
                    throw Exception("Oh No!")
                    logger.info("inner 1 ending")
                } catch (ex: Throwable) {
                    logger.info("inner 1: caught exception {} - {}", ex.javaClass.simpleName, ex.message)
                    throw ex
                }
            }

            val job2 = launch {
                try {
                    delay(2000)
                    logger.info("inner 2 ending")
                } catch (ex: Throwable) {
                    logger.info("inner 2: caught exception {} - {}", ex.javaClass.simpleName, ex.message)
                }
            }

            try {
                delay(2000)
            } catch (ex: Throwable) {
                logger.info("top: caught exception {} - {}", ex.javaClass.simpleName, ex.message)
            }
            logger.info("top ending")
        }
    }
}
----

* Why are exceptions thrown in the top coroutine and in the second child coroutine? In which statements are those exceptions thrown?
** As exce√ß√µes s√£o lan√ßadas na *coroutine* superior e na segunda *coroutine* filha porque ambas foram canceladas. A exce√ß√£o na *coroutine* superior √© lan√ßada na linha `throw Exception("Oh No!")` e a exce√ß√£o na segunda *coroutine* filha √© lan√ßada na linha `delay(2000)`.

* Does the `runBlocking` call end by throwing an exception?
** N√£o, a chamada `runBlocking` n√£o termina lan√ßando uma exce√ß√£o. A exce√ß√£o √© capturada no bloco `try-catch` e a execu√ß√£o continua.

* If `throw Exception(...)` is replaced with `throw CancellationException()`, what is the change in behavior?
** Se `throw Exception(...)` for substitu√≠do por `throw CancellationException()`, a exce√ß√£o `CancellationException` ser√° lan√ßada e a *coroutine* ser√° cancelada. A execu√ß√£o n√£o continuar√° e a mensagem `top ending` n√£o ser√° exibida.